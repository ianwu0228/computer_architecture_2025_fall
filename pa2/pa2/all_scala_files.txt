========================================
File: Alu.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import OP_TYPES._

class Alu_io extends Bundle {
  // inputs
  val src1      = Input(UInt(32.W))
  val src2      = Input(UInt(32.W))
  val pc        = Input(UInt(32.W))
  val imm       = Input(UInt(32.W))
  val aluOp     = Input(UInt(5.W))
  // outputs
  val to_branch  = Output(Bool())      // true when branch/jump is taken
  val alu_result = Output(UInt(32.W))  // main ALU output / write-back value
  val jump_addr  = Output(UInt(32.W))  // branch/jump target
}

class Alu extends Module {
  val io = IO(new Alu_io())

  // defaults
  val to_branch  = WireDefault(false.B)
  val alu_result = WireDefault(0.U(32.W))
  val jump_addr  = WireDefault(0.U(32.W))

  val shamt = io.src2(4,0)              // shift amount uses low 5 bits
  val src1_s = io.src1.asSInt
  val src2_s = io.src2.asSInt

  switch(io.aluOp) {
    // ------------------------------------------------------------
    // Basic arithmetic / logic
    // ------------------------------------------------------------
    is(OP_ADD)   { alu_result := io.src1 + io.src2 }
    is(OP_SUB)   { alu_result := io.src1 - io.src2 }
    is(OP_AND)   { alu_result := io.src1 & io.src2 }
    is(OP_OR)    { alu_result := io.src1 | io.src2 }
    is(OP_XOR)   { alu_result := io.src1 ^ io.src2 }
    is(OP_SLT)   { alu_result := (src1_s < src2_s).asUInt }
    is(OP_SLL)   { alu_result := io.src1 << shamt }
    is(OP_SRL)   { alu_result := io.src1 >> shamt }
    is(OP_SRA)   { alu_result := (src1_s >> shamt).asUInt }

    // ------------------------------------------------------------
    // LUI / AUIPC
    // ------------------------------------------------------------
    is(OP_LUI)   { alu_result := io.imm }             // LUI writes imm directly
    is(OP_AUIPC) { alu_result := io.pc + io.imm }     // AUIPC: pc + imm

    // ------------------------------------------------------------
    // Branches
    // (we compute both branch decision & target here)
    // ------------------------------------------------------------
    is(OP_BEQ) {
      to_branch := (io.src1 === io.src2)
      jump_addr := io.pc + io.imm
    }
    is(OP_BNE) {
      to_branch := (io.src1 =/= io.src2)
      jump_addr := io.pc + io.imm
    }
    is(OP_BLT) {
      to_branch := (src1_s < src2_s)
      jump_addr := io.pc + io.imm
    }
    is(OP_BGE) {
      to_branch := (src1_s >= src2_s)
      jump_addr := io.pc + io.imm
    }

    // ------------------------------------------------------------
    // Jumps (JAL / JALR)
    // ------------------------------------------------------------
    is(OP_JAL) {
      // rd = pc + 4, PC <- pc + imm
      alu_result := io.pc + 4.U
      to_branch  := true.B
      jump_addr  := io.pc + io.imm
    }
    is(OP_JALR) {
      // rd = pc + 4, PC <- (rs1 + imm) & ~1
      alu_result := io.pc + 4.U
      to_branch  := true.B
      jump_addr  := (io.src1 + io.imm) & (~1.U(32.W))
    }

    // ------------------------------------------------------------
    // NOP / default
    // ------------------------------------------------------------
    is(OP_NOP) {
      // nothing; defaults already zero
    }
  }

  io.alu_result := alu_result
  io.to_branch  := to_branch
  io.jump_addr  := jump_addr
}



========================================
File: Bundles.scala
========================================
package cpu

import chisel3._

// collect all control signals
class CtrlSignal extends Bundle {
    val ctrlJump = Output(Bool())
    val ctrlBranch = Output(Bool())
    val ctrlRegWrite = Output(Bool())
    val ctrlMemRead = Output(Bool())
    val ctrlMemWrite = Output(Bool())
    val ctrlALUSrc = Output(Bool())
    val ctrlALUOp = Output(UInt(5.W))
    val ctrlMemToReg = Output(Bool())
}

// collect all register addresses
class RegAddr extends Bundle {
    val rs1_addr = Output(UInt(5.W))
    val rs2_addr = Output(UInt(5.W))
    val rd_addr = Output(UInt(5.W))
}

// ALUOp values
object OP_TYPES { 
    val OP_NOP = "b00000".U
    val OP_ADD = "b00001".U
    val OP_SUB = "b00010".U
    val OP_AND = "b00011".U
    val OP_OR  = "b00100".U
    val OP_XOR = "b00101".U
    val OP_SLT = "b00110".U
    val OP_SLL = "b00111".U
    val OP_SRL = "b01000".U
    val OP_SRA = "b01001".U
    val OP_BEQ = "b01010".U
    val OP_BNE = "b01011".U
    val OP_BLT = "b01100".U
    val OP_BGE = "b01101".U
    val OP_JAL = "b01110".U
    val OP_JALR = "b01111".U
    val OP_LUI = "b10000".U
    val OP_AUIPC = "b10001".U
}


========================================
File: Core.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation}
import firrtl.options.TargetDirAnnotation

// io for testbench to access
class Core_io extends Bundle {
    // for debugging
    val pc = Output(UInt(32.W))
    val inst = Output(UInt(32.W))
    val wb_result = Output(UInt(32.W))
    // for grading, DO NOT MODIFY
    val peek_write = Output(Bool())
    val peek_addr = Output(UInt(32.W))
    val peek_data = Output(UInt(32.W))
}

class Core extends Module {
    val io = IO(new Core_io())

    // instantiate all the modules
    val pc_handle = Module(new PCHandle())
    val inst_mem = Module(new InstMem())
    val decoder = Module(new Decoder())
    val reg_file = Module(new Regfile())
    val alu = Module(new Alu())
    val data_mem = Module(new DataMem())

    /// TODO ///
    // connect all the modules here 
    
    // instantiate pipeline registers
    val if_id = Module(new Reg_IF_ID())
    val id_ex = Module(new Reg_ID_EX())
    val ex_mem = Module(new Reg_EX_MEM())
    val mem_wb = Module(new Reg_MEM_WB())


    // ------------------------------------------------------------
    // HAZARD DETECTION UNIT
    // ------------------------------------------------------------
    
    // Check if the instruction currently in EX stage is a LOAD
    val is_ex_load = id_ex.io.out.ctrl.ctrlMemRead

    // Check if the instruction in ID stage (Decoder output) reads from the load destination
    val rs1_conflict = (decoder.io.regs.rs1_addr === id_ex.io.out.rd_addr) && (id_ex.io.out.rd_addr =/= 0.U)
    val rs2_conflict = (decoder.io.regs.rs2_addr === id_ex.io.out.rd_addr) && (id_ex.io.out.rd_addr =/= 0.U)

    // Detect Load-Use Hazard
    val load_use_hazard = is_ex_load && (rs1_conflict || rs2_conflict)


    // ------------------------------------------------------------
    // IF stage
    // ------------------------------------------------------------
    
    // stall the pc_handle when load-use hazard detected
    pc_handle.io.stall := load_use_hazard  // Freeze PC
    
    
    // assign the pc variables
    pc_handle.io.to_branch := alu.io.to_branch 
    pc_handle.io.jump_addr := alu.io.jump_addr


    // assign the instruction memory address
    inst_mem.io.addr := pc_handle.io.pc


    val inst_wire = inst_mem.io.inst

    // prepare the input for IF/ID pipeline register
    // if_id.io.in.pc := pc_handle.io.pc
    if_id.io.in.pc := RegNext(pc_handle.io.pc)
    if_id.io.in.inst := inst_mem.io.inst
    
    // Stall IF/ID if hazard is detected (hold the instruction in ID)
    if_id.io.stall := load_use_hazard 
    if_id.io.flush := alu.io.to_branch

    // val flush_branch_latency = RegNext(alu.io.to_branch)

    // if_id.io.in.pc := RegNext(pc_handle.io.pc) // Keep your PC Delay fix!
    // if_id.io.in.inst := inst_mem.io.inst
    
    // if_id.io.stall := load_use_hazard 
    
    // // --- MODIFY THIS LINE ---
    // if_id.io.flush := alu.io.to_branch || flush_branch_latency
    // // ------------------------


    // ------------------------------------------------------------
    // ID stage
    // ------------------------------------------------------------
    

    // write back 
    reg_file.io.reg_write := mem_wb.io.out.ctrl.ctrlRegWrite
    reg_file.io.rd_addr := mem_wb.io.out.rd_addr
    reg_file.io.rd_data := Mux(mem_wb.io.out.ctrl.ctrlMemToReg, data_mem.io.data_out, mem_wb.io.out.alu_result) // either from mem (lw) or alu (add
    
    // decoder
    decoder.io.inst := if_id.io.out.inst

    // register file
    reg_file.io.rs1_addr := decoder.io.regs.rs1_addr
    reg_file.io.rs2_addr := decoder.io.regs.rs2_addr

    
    id_ex.io.in.rs1_addr := decoder.io.regs.rs1_addr
    id_ex.io.in.rs2_addr := decoder.io.regs.rs2_addr
   
    // stall and flush
    id_ex.io.stall := false.B
    id_ex.io.flush := load_use_hazard || alu.io.to_branch
    
    // prepare the input for ID/EX pipeline register
    id_ex.io.in.ctrl := decoder.io.ctrl
    id_ex.io.in.pc := if_id.io.out.pc
    id_ex.io.in.rs1_data := reg_file.io.rs1_data
    id_ex.io.in.rs2_data := reg_file.io.rs2_data
    id_ex.io.in.imm := decoder.io.imm
    id_ex.io.in.rd_addr := decoder.io.regs.rd_addr


    

    // ------------------------------------------------------------
    // EX stage
    // ------------------------------------------------------------

    // forwarding unit
    val forwarding_unit = Module(new ForwardingUnit())

    // Inputs from ID/EX (Current Stage)
    forwarding_unit.io.rs1_ex := id_ex.io.out.rs1_addr
    forwarding_unit.io.rs2_ex := id_ex.io.out.rs2_addr

    // Inputs from EX/MEM (Pipeline Reg for MEM stage)
    forwarding_unit.io.rd_mem := ex_mem.io.out.rd_addr
    forwarding_unit.io.reg_write_mem := ex_mem.io.out.ctrl.ctrlRegWrite

    // Inputs from MEM/WB (Pipeline Reg for WB stage)
    forwarding_unit.io.rd_wb := mem_wb.io.out.rd_addr
    forwarding_unit.io.reg_write_wb := mem_wb.io.out.ctrl.ctrlRegWrite

    // Define the data available for forwarding
    // Data from MEM stage (Result of the previous instruction)
    val forward_mem_data = ex_mem.io.out.alu_result 
    
    // Data from WB stage (Result of instruction 2 cycles ago)
    // Note: We use reg_file.io.rd_data because that holds the FINAL value (ALU result or Mem result)
    val forward_wb_data  = reg_file.io.rd_data 

    // --- ALU Source 1 Logic ---
    // 0 = Original, 1 = From WB, 2 = From MEM
    val forwarded_src1 = MuxLookup(forwarding_unit.io.forward_a, id_ex.io.out.rs1_data, Seq(
        0.U -> id_ex.io.out.rs1_data,
        1.U -> forward_wb_data,
        2.U -> forward_mem_data
    ))
    
    // --- ALU Source 2 Logic ---
    val forwarded_src2 = MuxLookup(forwarding_unit.io.forward_b, id_ex.io.out.rs2_data, Seq(
        0.U -> id_ex.io.out.rs2_data,
        1.U -> forward_wb_data,
        2.U -> forward_mem_data
    ))

    // --- Final Connection to ALU ---
    alu.io.src1 := forwarded_src1
    
    // Remember: Src2 can also be an Immediate!
    // The Mux for ALUSrc (Immediate vs Reg) happens AFTER forwarding
    alu.io.src2 := Mux(id_ex.io.out.ctrl.ctrlALUSrc, id_ex.io.out.imm, forwarded_src2)

    // data to ALU
    // // prepare ALU src1 and src2 with
    // val actual_src1 = id_ex.io.out.rs1_data
    // val actual_src2 = Mux(id_ex.io.out.ctrl.ctrlALUSrc, id_ex.io.out.imm, id_ex.io.out.rs2_data)

    // // ALU inputs
    // alu.io.src1 := actual_src1
    // alu.io.src2 := actual_src2
    alu.io.pc := id_ex.io.out.pc
    alu.io.imm := id_ex.io.out.imm
    alu.io.aluOp := id_ex.io.out.ctrl.ctrlALUOp

    // stall and flush
    ex_mem.io.stall := false.B
    ex_mem.io.flush := false.B

    // prepare the input for EX/MEM pipeline register
    ex_mem.io.in.alu_result := alu.io.alu_result
    ex_mem.io.in.rs2_data := forwarded_src2
    ex_mem.io.in.rd_addr := id_ex.io.out.rd_addr
    ex_mem.io.in.ctrl := id_ex.io.out.ctrl

    // ------------------------------------------------------------
    // MEM stage
    // ------------------------------------------------------------

    // data_mem inputs
    data_mem.io.ctrlMemRead := ex_mem.io.out.ctrl.ctrlMemRead || mem_wb.io.out.ctrl.ctrlMemToReg // to make sure the data_mem ctrlMemRead is high when lw in WB stage
    data_mem.io.ctrlMemWrite := ex_mem.io.out.ctrl.ctrlMemWrite
    data_mem.io.addr := ex_mem.io.out.alu_result
    data_mem.io.data_in := ex_mem.io.out.rs2_data

    // stall and flush
    mem_wb.io.stall := false.B
    mem_wb.io.flush := false.B

    // prepare the input for MEM/WB pipeline register
    mem_wb.io.in.alu_result := ex_mem.io.out.alu_result
    mem_wb.io.in.rd_addr := ex_mem.io.out.rd_addr
    mem_wb.io.in.ctrl := ex_mem.io.out.ctrl

    // ------------------------------------------------------------
    // WB stage
    // ------------------------------------------------------------ 



    // core
    io.pc := pc_handle.io.pc
    io.inst := inst_wire
    io.wb_result := Mux(mem_wb.io.out.ctrl.ctrlMemToReg, data_mem.io.data_out, mem_wb.io.out.alu_result)

    /// DO NOT MODIFY ///
    io.peek_write := data_mem.io.peek_write
    io.peek_addr := data_mem.io.addr
    io.peek_data := data_mem.io.data_in


}

/// You can add the following code
//  and generate verilog by command: sbt "runMain cpu.main" ///

// object main extends App {

//     (new ChiselStage).execute(
//     Array("--target-dir", "verilog_output"),
//     Seq(ChiselGeneratorAnnotation(() => new Core()))
//     )
// }





========================================
File: DataMem.scala
========================================
package cpu

import chisel3._
import chisel3.util._

/// DO NOT MODIFY THIS FILE /// 

class DataMem_io extends Bundle {
    val ctrlMemRead = Input(Bool())
    val ctrlMemWrite = Input(Bool())
    val addr = Input(UInt(32.W))
    val data_in = Input(UInt(32.W))
    val data_out = Output(UInt(32.W))
    val peek_write = Output(Bool())
}

class DataMem extends Module {
    val io = IO(new DataMem_io)

    val pipeline = sys.env.getOrElse("PIPELINE","0") == "1"
    // declare a memory that can store 1024 32-bit data
    val mem = if(pipeline) {
        SyncReadMem(1024, UInt(32.W))
    } else {
        Mem(1024, UInt(32.W))
    }

    // addr divided by 4, byte -> word address
    val index = io.addr >> 2.U 
    val peek_write = WireDefault(false.B)
    
    when(io.ctrlMemWrite) {
        mem.write(index, io.data_in)
        peek_write := true.B
    }
    
    io.peek_write := peek_write
    io.data_out := Mux(io.ctrlMemRead, mem.read(index), 0.U)
    
}



========================================
File: Decoder.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import OP_TYPES._

class Decoder_io extends Bundle {
  val inst = Input(UInt(32.W))
  val ctrl = Output(new CtrlSignal)
  val regs = Output(new RegAddr)
  val imm  = Output(UInt(32.W))
}

class Decoder extends Module {
  val io = IO(new Decoder_io())

  val inst   = io.inst
  val opcode = inst(6,0)
  val rd     = inst(11,7)
  val funct3 = inst(14,12)
  val rs1    = inst(19,15)
  val rs2    = inst(24,20)
  val funct7 = inst(31,25)

  // Default outputs
  io.ctrl := 0.U.asTypeOf(new CtrlSignal)
  io.regs.rs1_addr := rs1
  io.regs.rs2_addr := rs2
  io.regs.rd_addr  := rd
  io.imm := 0.U

  // Opcodes  (RENAMED to avoid clashing with OP_TYPES)
  val OPC_R     = "b0110011".U
  val OPC_I_ALU = "b0010011".U
  val OPC_LOAD  = "b0000011".U
  val OPC_STORE = "b0100011".U
  val OPC_BRANCH= "b1100011".U
  val OPC_JAL   = "b1101111".U
  val OPC_JALR  = "b1100111".U
  val OPC_LUI   = "b0110111".U
  val OPC_AUIPC = "b0010111".U

  // Sign-extend helper
  def sext(x: UInt, bits: Int): UInt = {
    Cat(Fill(32 - bits, x(bits-1)), x(bits-1,0))
  }

  switch(opcode) {
    // ------------------------------------------------------------
    // R-type (add, sub, and, or, xor, slt, sll, srl, sra)
    // ------------------------------------------------------------
    is(OPC_R) {
      io.ctrl.ctrlRegWrite := true.B

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SUB, OP_ADD) } // add/sub
        is("b111".U) { io.ctrl.ctrlALUOp := OP_AND }
        is("b110".U) { io.ctrl.ctrlALUOp := OP_OR  }
        is("b100".U) { io.ctrl.ctrlALUOp := OP_XOR }
        is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }
        is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }
        is("b101".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) }
      }
    }

    // ------------------------------------------------------------
    // I-type ALU (addi, slti, slli, srli, srai)
    // ------------------------------------------------------------
    is(OPC_I_ALU) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.imm := sext(inst(31,20), 12)

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := OP_ADD }  // addi
        is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }  // slti
        is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }  // slli
        is("b101".U) {
          io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) // srai/srli
        }
      }
    }

    // ------------------------------------------------------------
    // LOAD (lw)
    // ------------------------------------------------------------
    is(OPC_LOAD) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlMemRead  := true.B
      io.ctrl.ctrlMemToReg := true.B
      io.ctrl.ctrlALUOp    := OP_ADD   // addr = rs1 + imm
      io.imm := sext(inst(31,20), 12)
    }

    // ------------------------------------------------------------
    // STORE (sw)
    // ------------------------------------------------------------
    is(OPC_STORE) {
      io.ctrl.ctrlMemWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlALUOp    := OP_ADD
      val immS = Cat(inst(31,25), inst(11,7))
      io.imm := sext(immS, 12)
    }

    // ------------------------------------------------------------
    // BRANCH (beq, bne, blt, bge)
    // ------------------------------------------------------------
    is(OPC_BRANCH) {
      io.ctrl.ctrlBranch := true.B
      val immB = Cat(inst(31), inst(7), inst(30,25), inst(11,8), 0.U(1.W))
      io.imm := sext(immB, 13)

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := OP_BEQ }
        is("b001".U) { io.ctrl.ctrlALUOp := OP_BNE }
        is("b100".U) { io.ctrl.ctrlALUOp := OP_BLT }
        is("b101".U) { io.ctrl.ctrlALUOp := OP_BGE }
      }
    }

    // ------------------------------------------------------------
    // JAL
    // ------------------------------------------------------------
    is(OPC_JAL) {
      io.ctrl.ctrlJump     := true.B
      io.ctrl.ctrlRegWrite := true.B
      val immJ = Cat(inst(31), inst(19,12), inst(20), inst(30,21), 0.U(1.W))
      io.imm := sext(immJ, 21)
      io.ctrl.ctrlALUOp := OP_JAL
    }

    // ------------------------------------------------------------
    // JALR
    // ------------------------------------------------------------
    is(OPC_JALR) {
      io.ctrl.ctrlJump     := true.B
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlALUOp    := OP_JALR
      io.imm := sext(inst(31,20), 12)
    }

    // ------------------------------------------------------------
    // LUI
    // ------------------------------------------------------------
    is(OPC_LUI) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUOp    := OP_LUI      // from OP_TYPES (ALU op), not opcode
      io.imm := Cat(inst(31,12), Fill(12, 0.U))
    }

    // ------------------------------------------------------------
    // AUIPC
    // ------------------------------------------------------------
    is(OPC_AUIPC) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUOp    := OP_AUIPC   // from OP_TYPES
      io.imm := Cat(inst(31,12), Fill(12, 0.U))
    }
  }
}



========================================
File: Forwarding.scala
========================================
package cpu
import chisel3._
import chisel3.util._

class ForwardingUnit extends Module {
    val io = IO(new Bundle {
        // Current Instruction (EX Stage)
        val rs1_ex = Input(UInt(5.W))
        val rs2_ex = Input(UInt(5.W))

        // Previous Instruction (MEM Stage)
        val rd_mem = Input(UInt(5.W))
        val reg_write_mem = Input(Bool())

        // 2nd Previous Instruction (WB Stage)
        val rd_wb = Input(UInt(5.W))
        val reg_write_wb = Input(Bool())

        // Forwarding Control Signals (0=No, 1=From WB, 2=From MEM)
        val forward_a = Output(UInt(2.W)) 
        val forward_b = Output(UInt(2.W))
    })

    // 1. Initialize Default Values (Crucial to prevent latches/unknown states)
    io.forward_a := 0.U
    io.forward_b := 0.U

    // -------------------------
    // Forward A (Source 1)
    // -------------------------

    // Priority 1: EX Hazard (Distance 1 - Forward from EX/MEM pipeline register)
    // Checks if the instruction currently in MEM stage wrote to Rs1
    when(io.reg_write_mem && io.rd_mem =/= 0.U && io.rd_mem === io.rs1_ex) {
        io.forward_a := 2.U  // Selects input from ALU result (EX/MEM)
    }
    // Priority 2: MEM Hazard (Distance 2 - Forward from MEM/WB pipeline register)
    // Checks if the instruction currently in WB stage wrote to Rs1
    // AND ensures that the EX Hazard (Priority 1) is NOT active (The "Blue Text" condition)
    .elsewhen(io.reg_write_wb && io.rd_wb =/= 0.U && io.rd_wb === io.rs1_ex && 
            !(io.reg_write_mem && io.rd_mem =/= 0.U && io.rd_mem === io.rs1_ex)) { // Explicit Double Hazard Check
        io.forward_a := 1.U  // Selects input from WB data (MEM/WB)
    }

    // -------------------------
    // Forward B (Source 2)
    // -------------------------

    // Priority 1: EX Hazard (Distance 1 - Forward from EX/MEM pipeline register)
    when(io.reg_write_mem && io.rd_mem =/= 0.U && io.rd_mem === io.rs2_ex) {
        io.forward_b := 2.U
    }
    // Priority 2: MEM Hazard (Distance 2 - Forward from MEM/WB pipeline register)
    .elsewhen(io.reg_write_wb && io.rd_wb =/= 0.U && io.rd_wb === io.rs2_ex && 
            !(io.reg_write_mem && io.rd_mem =/= 0.U && io.rd_mem === io.rs2_ex)) { // Explicit Double Hazard Check
        io.forward_b := 1.U
    }
}


========================================
File: InstMem.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import chisel3.util.experimental.loadMemoryFromFile
import firrtl.annotations.MemoryLoadFileType

/// DO NOT MODIFY THIS FILE /// 

class InstMem_io extends Bundle {
    val addr = Input(UInt(32.W)) 
    val inst = Output(UInt(32.W))
}

class InstMem() extends Module {
    val io = IO(new InstMem_io()) 

    // addr divided by 4, byte -> word address
    val index = io.addr >> 2.U 

    val pipeline = sys.env.getOrElse("PIPELINE","0") == "1"

    // declare a memory that can store 1024 32-bit instructions
    val mem: MemBase[UInt] = if(pipeline) {
        SyncReadMem(1024, UInt(32.W))
    } else {
        Mem(1024, UInt(32.W))
    }

    val inst_file = sys.env.getOrElse("INST_FILE", "src/test/pattern/p1.hex")
    loadMemoryFromFile(mem, inst_file, MemoryLoadFileType.Hex)
    println(s"Loading instruction memory from: " + inst_file)
    
    io.inst := mem.read(index)
}



========================================
File: PCHandle.scala
========================================
package cpu

import chisel3._
import chisel3.util._

class PCHandle_io extends Bundle {
  val to_branch = Input(Bool())
  val jump_addr = Input(UInt(32.W))
  val pc        = Output(UInt(32.W))
  val stall     = Input(Bool())
}

class PCHandle extends Module {
  val io = IO(new PCHandle_io())

  val pc = RegInit(0.U(32.W))

  // basic next PC logic: PC+4 or branch/jump target
  val next_pc = Mux(io.to_branch, io.jump_addr, pc + 4.U)

  // Only update PC if NOT stalled
  when(!io.stall) {
      pc := next_pc
  }

  // io.pc := pc
  
  // to make sure when stalled, the output pc remains the same as previous cycle
  // io.pc := Mux(io.stall, pc - 4.U, pc)
  io.pc := Mux(io.stall, pc - 4.U,
             Mux(io.to_branch, io.jump_addr, pc))

}


========================================
File: Reg_EX_MEM.scala
========================================
package cpu

import chisel3._


class EX_MEM_Bundle extends Bundle {
    val alu_result = UInt(32.W)
    val rs2_data   = UInt(32.W)
    val rd_addr    = UInt(5.W)
    val ctrl       = new CtrlSignal

}


class Reg_EX_MEM extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new EX_MEM_Bundle)
    val out   = Output(new EX_MEM_Bundle)
  })

  val alu_result_ex     = RegInit(0.U(32.W))
  val rs2_data_ex       = RegInit(0.U(32.W))
  val rd_addr_ex        = RegInit(0.U(5.W))
  val ctrl_ex           = RegInit(0.U.asTypeOf(new CtrlSignal))

  when (io.flush) {
    alu_result_ex     := 0.U
    rs2_data_ex       := 0.U
    rd_addr_ex        := 0.U
    ctrl_ex           := 0.U.asTypeOf(new CtrlSignal)
  } .elsewhen (!io.stall) {
    // --- STANDARD LOGIC ONLY ---
    // Just capture the next instruction. 
    // If it's a bubble, we WANT zeros to flow through.
    alu_result_ex     := io.in.alu_result
    rs2_data_ex       := io.in.rs2_data
    rd_addr_ex        := io.in.rd_addr
    ctrl_ex           := io.in.ctrl
  }

  io.out.alu_result := alu_result_ex
  io.out.rs2_data   := rs2_data_ex
  io.out.rd_addr    := rd_addr_ex
  io.out.ctrl       := ctrl_ex
}


========================================
File: Reg_ID_EX.scala
========================================
package cpu

import chisel3._

class ID_EX_Bundle extends Bundle {
    val ctrl      = new CtrlSignal
    val pc        = UInt(32.W)
    val rs1_data  = UInt(32.W)
    val rs2_data  = UInt(32.W)
    val imm       = UInt(32.W)
    val rd_addr   = UInt(5.W)
    // forwarding
    val rs1_addr  = UInt(5.W)
    val rs2_addr  = UInt(5.W)
}



class Reg_ID_EX extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new ID_EX_Bundle)
    val out   = Output(new ID_EX_Bundle)
  })

  // real registers
  val ctrl_id     = RegInit(0.U.asTypeOf(new CtrlSignal))
  val pc_id       = RegInit(0.U(32.W))
  val rs1_data_id = RegInit(0.U(32.W))
  val rs2_data_id = RegInit(0.U(32.W))
  val imm_id      = RegInit(0.U(32.W))
  val rd_addr_id  = RegInit(0.U(5.W))
  val rs1_addr_id = RegInit(0.U(5.W))
  val rs2_addr_id = RegInit(0.U(5.W))

  when (io.flush) {
    ctrl_id     := 0.U.asTypeOf(new CtrlSignal)
    pc_id       := 0.U
    rs1_data_id := 0.U
    rs2_data_id := 0.U
    imm_id      := 0.U
    rd_addr_id  := 0.U
    rs1_addr_id := 0.U
    rs2_addr_id := 0.U
  } .elsewhen (!io.stall) {
    ctrl_id     := io.in.ctrl
    pc_id       := io.in.pc
    rs1_data_id := io.in.rs1_data
    rs2_data_id := io.in.rs2_data
    imm_id      := io.in.imm
    rd_addr_id  := io.in.rd_addr
    rs1_addr_id := io.in.rs1_addr
    rs2_addr_id := io.in.rs2_addr
  }

  io.out.ctrl     := ctrl_id
  io.out.pc       := pc_id
  io.out.rs1_data := rs1_data_id
  io.out.rs2_data := rs2_data_id
  io.out.imm      := imm_id
  io.out.rd_addr  := rd_addr_id

  io.out.rs1_addr := rs1_addr_id
  io.out.rs2_addr := rs2_addr_id
}


========================================
File: Reg_IF_ID.scala
========================================
package cpu

import chisel3._

class IF_ID_Bundle extends Bundle {
  val pc   = UInt(32.W)
  val inst = UInt(32.W)
}

class Reg_IF_ID extends Module {
  val io = IO(new Bundle {
    val in    = Input(new IF_ID_Bundle())
    val stall = Input(Bool())
    val flush = Input(Bool())
    val out   = Output(new IF_ID_Bundle())
  })

  // pipeline registers between IF and ID
  val pc_if   = RegInit(0.U(32.W))
  val inst_if = RegInit(0.U(32.W))

  when (io.flush) {
    pc_if   := 0.U
    inst_if := 0.U  // treat as bubble / NOP
  } .elsewhen (!io.stall) {
    pc_if   := io.in.pc
    inst_if := io.in.inst
  }

  io.out.pc   := pc_if
  io.out.inst := inst_if
}



========================================
File: Reg_MEM_WB.scala
========================================
package cpu

import chisel3._


class MEM_WB_Bundle extends Bundle {
    val alu_result = UInt(32.W)
    val rd_addr    = UInt(5.W)
    val ctrl       = new CtrlSignal
}

class Reg_MEM_WB extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new MEM_WB_Bundle)
    val out   = Output(new MEM_WB_Bundle)
  })

  // real registers
  val alu_result_mem     = RegInit(0.U(32.W))
  val rd_addr_mem        = RegInit(0.U(5.W))
  val ctrl_mem           = RegInit(0.U.asTypeOf(new CtrlSignal))

  when (io.flush) {
    alu_result_mem     := 0.U
    rd_addr_mem        := 0.U
    ctrl_mem           := 0.U.asTypeOf(new CtrlSignal)
  } .elsewhen (!io.stall) {
    alu_result_mem     := io.in.alu_result
    rd_addr_mem        := io.in.rd_addr
    ctrl_mem           := io.in.ctrl
  }

  io.out.alu_result := alu_result_mem
  io.out.rd_addr    := rd_addr_mem
  io.out.ctrl       := ctrl_mem
}


========================================
File: Regfile.scala
========================================
// package cpu

// import chisel3._
// import chisel3.util._

// class Regfile_io extends Bundle {
//     /// TODO ///
//     // read ports
//     val rs1_addr = Input(UInt(5.W))
//     val rs2_addr = Input(UInt(5.W))
//     val rs1_data = Output(UInt(32.W))
//     val rs2_data = Output(UInt(32.W))
//     // write port
//     val rd_addr  = Input(UInt(5.W))
//     val rd_data  = Input(UInt(32.W))
//     val reg_write = Input(Bool())
// }

// class Regfile extends Module {
//     val io = IO(new Regfile_io())

//     // declare 32 registers each 32 bits
//     val regs = Reg(Vec(32, UInt(32.W)))

//     /// TODO ///

//     // read ports (x0 always 0)
//     io.rs1_data := Mux(io.rs1_addr === 0.U, 0.U, regs(io.rs1_addr))
//     io.rs2_data := Mux(io.rs2_addr === 0.U, 0.U, regs(io.rs2_addr))

//     when(io.rs1_addr === 0.U)
//     {
//         io.rs1_data := 0.U
//     }
//     when(io.rs2_addr === 0.U)
//     {
//         io.rs2_data := 0.U
//     }

    

//     // write  
//     when(io.reg_write && io.rd_addr =/= 0.U)
//     {
//         regs(io.rd_addr) := io.rd_data
//     }


// }


package cpu

import chisel3._
import chisel3.util._

class Regfile_io extends Bundle {
    val rs1_addr = Input(UInt(5.W))
    val rs2_addr = Input(UInt(5.W))
    val rs1_data = Output(UInt(32.W))
    val rs2_data = Output(UInt(32.W))
    val rd_addr  = Input(UInt(5.W))
    val rd_data  = Input(UInt(32.W))
    val reg_write = Input(Bool())
}

class Regfile extends Module {
    val io = IO(new Regfile_io())

    // declare 32 registers each 32 bits
    val regs = Reg(Vec(32, UInt(32.W)))

    // --- FIX START ---
    // 1. Read from the register array (The "Old" value)
    val r1_data_raw = regs(io.rs1_addr)
    val r2_data_raw = regs(io.rs2_addr)

    // 2. Internal Forwarding (Collision Detection)
    // Check if we are reading the same register that is currently being written
    val bypass_rs1 = io.reg_write && (io.rd_addr === io.rs1_addr) && (io.rs1_addr =/= 0.U)
    val bypass_rs2 = io.reg_write && (io.rd_addr === io.rs2_addr) && (io.rs2_addr =/= 0.U)

    // 3. Mux to select the data (Forwarded vs. Array)
    io.rs1_data := Mux(bypass_rs1, io.rd_data, r1_data_raw)
    io.rs2_data := Mux(bypass_rs2, io.rd_data, r2_data_raw)

    // 4. Force x0 to be 0 (overrides everything)
    when(io.rs1_addr === 0.U) { io.rs1_data := 0.U }
    when(io.rs2_addr === 0.U) { io.rs2_data := 0.U }
    // --- FIX END ---

    // write  
    when(io.reg_write && io.rd_addr =/= 0.U) {
        regs(io.rd_addr) := io.rd_data
    }
}


