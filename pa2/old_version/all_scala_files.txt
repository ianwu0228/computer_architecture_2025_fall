========================================
File: Alu.scala
========================================
// package cpu

// import chisel3._
// import chisel3.util._
// import cpu.OP_TYPES._

// class Alu_io extends Bundle {
//     val to_branch = Output(Bool())
//     val alu_result = Output(UInt(32.W))
//     val jump_addr = Output(UInt(32.W))
//     /// TODO ///
//     val src1      = Input(UInt(32.W))
//     val src2      = Input(UInt(32.W))
//     val pc        = Input(UInt(32.W))
//     val imm       = Input(UInt(32.W))
//     val aluOp     = Input(UInt(5.W))
// }

// class Alu extends Module {
//     val io = IO(new Alu_io())

//     val to_branch = WireDefault(false.B)
//     val alu_result = WireDefault(0.U(32.W))
//     val jump_addr = WireDefault(0.U(32.W))

//     /// TODO ///

//     // temporary: NOP behavior, we'll fill later
//     switch(io.aluOp) {
//         is(OP_NOP) {
//         alu_result := 0.U
//         }
//         // weâ€™ll add real ADD/SUB/AND/OR/etc. later
//     }

//     io.alu_result := alu_result
//     io.to_branch := to_branch
//     io.jump_addr := jump_addr
// }


package cpu

import chisel3._
import chisel3.util._
import OP_TYPES._

class Alu_io extends Bundle {
  val src1      = Input(UInt(32.W))
  val src2      = Input(UInt(32.W))
  val pc        = Input(UInt(32.W))
  val imm       = Input(UInt(32.W))
  val aluOp     = Input(UInt(5.W))

  val to_branch  = Output(Bool())      // true when branch/jump is taken
  val alu_result = Output(UInt(32.W))  // main ALU output / write-back value
  val jump_addr  = Output(UInt(32.W))  // branch/jump target
}

class Alu extends Module {
  val io = IO(new Alu_io())

  // defaults
  val to_branch  = WireDefault(false.B)
  val alu_result = WireDefault(0.U(32.W))
  val jump_addr  = WireDefault(0.U(32.W))

  val shamt = io.src2(4,0)              // shift amount uses low 5 bits
  val src1_s = io.src1.asSInt
  val src2_s = io.src2.asSInt

  switch(io.aluOp) {
    // ------------------------------------------------------------
    // Basic arithmetic / logic
    // ------------------------------------------------------------
    is(OP_ADD)   { alu_result := io.src1 + io.src2 }
    is(OP_SUB)   { alu_result := io.src1 - io.src2 }
    is(OP_AND)   { alu_result := io.src1 & io.src2 }
    is(OP_OR)    { alu_result := io.src1 | io.src2 }
    is(OP_XOR)   { alu_result := io.src1 ^ io.src2 }
    is(OP_SLT)   { alu_result := (src1_s < src2_s).asUInt }
    is(OP_SLL)   { alu_result := io.src1 << shamt }
    is(OP_SRL)   { alu_result := io.src1 >> shamt }
    is(OP_SRA)   { alu_result := (src1_s >> shamt).asUInt }

    // ------------------------------------------------------------
    // LUI / AUIPC
    // ------------------------------------------------------------
    is(OP_LUI)   { alu_result := io.imm }             // LUI writes imm directly
    is(OP_AUIPC) { alu_result := io.pc + io.imm }     // AUIPC: pc + imm

    // ------------------------------------------------------------
    // Branches
    // (we compute both branch decision & target here)
    // ------------------------------------------------------------
    is(OP_BEQ) {
      to_branch := (io.src1 === io.src2)
      jump_addr := io.pc + io.imm
    }
    is(OP_BNE) {
      to_branch := (io.src1 =/= io.src2)
      jump_addr := io.pc + io.imm
    }
    is(OP_BLT) {
      to_branch := (src1_s < src2_s)
      jump_addr := io.pc + io.imm
    }
    is(OP_BGE) {
      to_branch := (src1_s >= src2_s)
      jump_addr := io.pc + io.imm
    }

    // ------------------------------------------------------------
    // Jumps (JAL / JALR)
    // ------------------------------------------------------------
    is(OP_JAL) {
      // rd = pc + 4, PC <- pc + imm
      alu_result := io.pc + 4.U
      to_branch  := true.B
      jump_addr  := io.pc + io.imm
    }
    is(OP_JALR) {
      // rd = pc + 4, PC <- (rs1 + imm) & ~1
      alu_result := io.pc + 4.U
      to_branch  := true.B
      jump_addr  := (io.src1 + io.imm) & (~1.U(32.W))
    }

    // ------------------------------------------------------------
    // NOP / default
    // ------------------------------------------------------------
    is(OP_NOP) {
      // nothing; defaults already zero
    }
  }

  io.alu_result := alu_result
  io.to_branch  := to_branch
  io.jump_addr  := jump_addr
}



========================================
File: Bundles.scala
========================================
// package cpu

// import chisel3._

// // collect all control signals
// class CtrlSignal extends Bundle {
//     val ctrlJump = Output(Bool())
//     val ctrlBranch = Output(Bool())
//     val ctrlRegWrite = Output(Bool())
//     val ctrlMemRead = Output(Bool())
//     val ctrlMemWrite = Output(Bool())
//     val ctrlALUSrc = Output(Bool())
//     val ctrlALUOp = Output(UInt(5.W))
//     val ctrlMemToReg = Output(Bool())
// }

// // collect all register addresses
// class RegAddr extends Bundle {
//     val rs1_addr = Output(UInt(5.W))
//     val rs2_addr = Output(UInt(5.W))
//     val rd_addr = Output(UInt(5.W))
// }

// // ALUOp values
// object OP_TYPES { 
//     val OP_NOP = "b00000".U
//     val OP_ADD = "b00001".U
//     val OP_SUB = "b00010".U
//     val OP_AND = "b00011".U
//     val OP_OR  = "b00100".U
//     val OP_XOR = "b00101".U
//     val OP_SLT = "b00110".U
//     val OP_SLL = "b00111".U
//     val OP_SRL = "b01000".U
//     val OP_SRA = "b01001".U
//     val OP_BEQ = "b01010".U
//     val OP_BNE = "b01011".U
//     val OP_BLT = "b01100".U
//     val OP_BGE = "b01101".U
//     val OP_JAL = "b01110".U
//     val OP_JALR = "b01111".U
//     val OP_LUI = "b10000".U
//     val OP_AUIPC = "b10001".U
// }

package cpu

import chisel3._

// collect all control signals (no directions here)
class CtrlSignal extends Bundle {
  val ctrlJump     = Bool()
  val ctrlBranch   = Bool()
  val ctrlRegWrite = Bool()
  val ctrlMemRead  = Bool()
  val ctrlMemWrite = Bool()
  val ctrlALUSrc   = Bool()
  val ctrlALUOp    = UInt(5.W)
  val ctrlMemToReg = Bool()
}

// collect all register addresses (no directions here)
class RegAddr extends Bundle {
  val rs1_addr = UInt(5.W)
  val rs2_addr = UInt(5.W)
  val rd_addr  = UInt(5.W)
}

// ALUOp values
object OP_TYPES {
  val OP_NOP   = "b00000".U
  val OP_ADD   = "b00001".U
  val OP_SUB   = "b00010".U
  val OP_AND   = "b00011".U
  val OP_OR    = "b00100".U
  val OP_XOR   = "b00101".U
  val OP_SLT   = "b00110".U
  val OP_SLL   = "b00111".U
  val OP_SRL   = "b01000".U
  val OP_SRA   = "b01001".U
  val OP_BEQ   = "b01010".U
  val OP_BNE   = "b01011".U
  val OP_BLT   = "b01100".U
  val OP_BGE   = "b01101".U
  val OP_JAL   = "b01110".U
  val OP_JALR  = "b01111".U
  val OP_LUI   = "b10000".U
  val OP_AUIPC = "b10001".U
}



========================================
File: Core.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation}
import firrtl.options.TargetDirAnnotation

// io for testbench to access
class Core_io extends Bundle {
  // for debugging
  val pc        = Output(UInt(32.W))
  val inst      = Output(UInt(32.W))
  val wb_result = Output(UInt(32.W))
  // for grading, DO NOT MODIFY
  val peek_write = Output(Bool())
  val peek_addr  = Output(UInt(32.W))
  val peek_data  = Output(UInt(32.W))
}

class Core extends Module {
  val io = IO(new Core_io())

  // ------------------------------------------------------------
  // Instantiate shared modules
  // ------------------------------------------------------------
  val pc_handle = Module(new PCHandle())
  val inst_mem  = Module(new InstMem())
  val decoder   = Module(new Decoder())
  val reg_file  = Module(new Regfile())
  val alu       = Module(new Alu())
  val data_mem  = Module(new DataMem())

  // ------------------------------------------------------------
  // IF stage
  // ------------------------------------------------------------
  pc_handle.io.to_branch := false.B
  pc_handle.io.jump_addr := 0.U

  inst_mem.io.addr := pc_handle.io.pc
  val inst_if = inst_mem.io.inst

  val if_id    = Module(new Reg_IF_ID())
  val if_id_in = Wire(new IF_ID_Bundle)
  if_id_in.pc   := pc_handle.io.pc
  if_id_in.inst := inst_if

  if_id.io.stall := false.B
  if_id.io.flush := false.B
  if_id.io.in    := if_id_in

  val pc_id   = if_id.io.out.pc
  val inst_id = if_id.io.out.inst

  // ------------------------------------------------------------
  // ID stage
  // ------------------------------------------------------------
  decoder.io.inst := inst_id

  reg_file.io.rs1_addr := decoder.io.regs.rs1_addr
  reg_file.io.rs2_addr := decoder.io.regs.rs2_addr
  reg_file.io.rd_addr  := 0.U
  reg_file.io.wdata    := 0.U
  reg_file.io.wen      := false.B

  val id_ex    = Module(new Reg_ID_EX())
  val id_ex_in = Wire(new ID_EX_Bundle)

  id_ex_in.pc        := pc_id
  id_ex_in.rs1_data  := reg_file.io.rs1_data
  id_ex_in.rs2_data  := reg_file.io.rs2_data
  id_ex_in.imm       := decoder.io.imm
  id_ex_in.regs      := decoder.io.regs
  id_ex_in.ctrl      := decoder.io.ctrl

  id_ex.io.stall := false.B
  id_ex.io.flush := false.B
  id_ex.io.in    := id_ex_in

  val ex_in = id_ex.io.out


  // ------------------------------------------------------------
  // Forwarding Unit 
  // ------------------------------------------------------------
  

  val forward_unit = Module(new ForwardUnit())

  forward_unit.io.ex_mem_regwrite := ex_in.ctrl.ctrlRegWrite
  forward_unit.io.ex_mem_rd       := ex_in.regs.rd_addr
  forward_unit.io.mem_wb_regwrite := mem_wb_in.ctrl.ctrlRegWrite
  forward_unit.io.mem_wb_rd       := mem_wb_in.regs.rd_addr
  forward_unit.io.id_ex_rs1       := ex_in.regs.rs1_addr
  forward_unit.io.id_ex_rs2       := ex_in.regs.rs2_addr

  forward_unit.io.forwardA        := forward_unit.io.forwardA

  // raw EX sources
  val ex_src1_raw = ex_in.rs1_data
  val ex_src2_raw = ex_in.rs2_data

  // ALU src2 consider immediate
  val ex_alu_src2 = Mux(ex_in.ctrl.ctrlALUSrc, ex_in.imm, ex_src2_raw)

  // final EX sources after forwarding
  val ex_src1 = Wire(UInt(32.W))
  val ex_src2 = Wire(UInt(32.W))

  // default no forwarding
  ex_src1 := ex_src1_raw
  ex_src2 := ex_alu_src2

  // EX hazard
  when(forward_unit.io.forwardA === "b10".U){
    ex_src1 := ex_mem_in.alu_res
  }
  when(forward_unit.io.forwardB === "b10".U){
    ex_src2 := ex_mem_in.alu_res
  }

  // MEM hazard
  when(forward_unit.io.forwardA === "b01".U){
    ex_src1 := wb_data
  }
  when(forward_unit.io.forwardB === "b01".U){
    ex_src2 := wb_data
  }




  // ------------------------------------------------------------
  // EX stage
  // ------------------------------------------------------------
  val alu_src2 = Mux(ex_in.ctrl.ctrlALUSrc, ex_in.imm, ex_in.rs2_data)

  alu.io.src1  := ex_src1
  alu.io.src2  := ex_src2
  alu.io.pc    := ex_in.pc
  alu.io.imm   := ex_in.imm
  alu.io.aluOp := ex_in.ctrl.ctrlALUOp

  val ex_mem    = Module(new Reg_EX_MEM())
  val ex_mem_in = Wire(new EX_MEM_Bundle)

  ex_mem_in.pc       := ex_in.pc
  ex_mem_in.alu_res  := alu.io.alu_result
  ex_mem_in.rs2_data := ex_in.rs2_data
  ex_mem_in.regs     := ex_in.regs
  ex_mem_in.ctrl     := ex_in.ctrl

  ex_mem.io.stall := false.B
  ex_mem.io.flush := false.B
  ex_mem.io.in    := ex_mem_in

  // data_mem.io.addr := ex_mem_in.alu_res
  val mem_in = ex_mem.io.out

  // ------------------------------------------------------------
  // MEM stage
  // ------------------------------------------------------------
  
  // data_mem.io.ctrlMemRead  := mem_in.ctrl.ctrlMemRead
  val delayedMemRead  = RegNext(mem_in.ctrl.ctrlMemRead, 0.B)
  data_mem.io.ctrlMemRead  := delayedMemRead



  data_mem.io.ctrlMemWrite := mem_in.ctrl.ctrlMemWrite
  data_mem.io.addr         := mem_in.alu_res
  data_mem.io.data_in      := mem_in.rs2_data

  val mem_wb    = Module(new Reg_MEM_WB())
  val mem_wb_in = Wire(new MEM_WB_Bundle)

  // carry everything *except* the memory data
  mem_wb_in.pc       := mem_in.pc
  mem_wb_in.alu_res  := mem_in.alu_res
  mem_wb_in.regs     := mem_in.regs
  mem_wb_in.ctrl     := mem_in.ctrl

  // mem_data is not used for loads when memory is synchronous
  mem_wb_in.mem_data := 0.U  // or mem_in.alu_res, doesn't matter


  mem_wb.io.stall := false.B
  mem_wb.io.flush := false.B
  mem_wb.io.in    := mem_wb_in

  val wb_in = mem_wb.io.out

  // ------------------------------------------------------------
  // WB stage
  // ------------------------------------------------------------
  val wb_data = Mux(mem_wb.io.out.ctrl.ctrlMemToReg,
                    data_mem.io.data_out,  // <- use memory output here
                    wb_in.alu_res)


  
  reg_file.io.wen     := wb_in.ctrl.ctrlRegWrite
  reg_file.io.rd_addr := wb_in.regs.rd_addr
  reg_file.io.wdata   := wb_data


  // ------------------------------------------------------------
  // Outputs
  // ------------------------------------------------------------
  io.pc        := pc_handle.io.pc
  io.inst      := inst_if
  io.wb_result := wb_data

  /// DO NOT MODIFY ///
  io.peek_write := data_mem.io.peek_write
  io.peek_addr  := data_mem.io.addr
  io.peek_data  := data_mem.io.data_in
}




========================================
File: DataMem.scala
========================================
package cpu

import chisel3._
import chisel3.util._

/// DO NOT MODIFY THIS FILE /// 

class DataMem_io extends Bundle {
    val ctrlMemRead = Input(Bool())
    val ctrlMemWrite = Input(Bool())
    val addr = Input(UInt(32.W))
    val data_in = Input(UInt(32.W))
    val data_out = Output(UInt(32.W))
    val peek_write = Output(Bool())
}

class DataMem extends Module {
    val io = IO(new DataMem_io)

    val pipeline = sys.env.getOrElse("PIPELINE","0") == "1"
    // declare a memory that can store 1024 32-bit data
    val mem = if(pipeline) {
        SyncReadMem(1024, UInt(32.W))
    } else {
        Mem(1024, UInt(32.W))
    }

    // addr divided by 4, byte -> word address
    val index = io.addr >> 2.U 
    val peek_write = WireDefault(false.B)
    
    when(io.ctrlMemWrite) {
        mem.write(index, io.data_in)
        peek_write := true.B
    }
    
    io.peek_write := peek_write
    io.data_out := Mux(io.ctrlMemRead, mem.read(index), 0.U)
    
}



========================================
File: Decoder.scala
========================================
// package cpu

// import chisel3._
// import chisel3.util._
// import OP_TYPES._

// class Decoder_io extends Bundle {
//   val inst = Input(UInt(32.W))
//   val ctrl = Output(new CtrlSignal)
//   val regs = Output(new RegAddr)
//   val imm  = Output(UInt(32.W))
// }

// class Decoder extends Module {
//   val io = IO(new Decoder_io())

//   val inst   = io.inst
//   val opcode = inst(6,0)
//   val rd     = inst(11,7)
//   val funct3 = inst(14,12)
//   val rs1    = inst(19,15)
//   val rs2    = inst(24,20)
//   val funct7 = inst(31,25)

//   // Default outputs
//   io.ctrl := 0.U.asTypeOf(new CtrlSignal)
//   io.regs.rs1_addr := rs1
//   io.regs.rs2_addr := rs2
//   io.regs.rd_addr  := rd
//   io.imm := 0.U

//   // Opcodes
//   val OP_R     = "b0110011".U
//   val OP_I_ALU = "b0010011".U
//   val OP_LOAD  = "b0000011".U
//   val OP_STORE = "b0100011".U
//   val OP_BRANCH= "b1100011".U
//   val OP_JAL   = "b1101111".U
//   val OP_JALR  = "b1100111".U
//   val OP_LUI   = "b0110111".U
//   val OP_AUIPC = "b0010111".U

//   // Sign-extend helper
//   def sext(x: UInt, bits: Int): UInt = {
//     Cat(Fill(32 - bits, x(bits-1)), x(bits-1,0))
//   }

//   switch(opcode) {
//     // ------------------------------------------------------------
//     // R-type (add, sub, and, or, xor, slt, sll, srl, sra)
//     // ------------------------------------------------------------
//     is(OP_R) {
//       io.ctrl.ctrlRegWrite := true.B

//       switch(funct3) {
//         is("b000".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SUB, OP_ADD) } // add/sub
//         is("b111".U) { io.ctrl.ctrlALUOp := OP_AND }
//         is("b110".U) { io.ctrl.ctrlALUOp := OP_OR  }
//         is("b100".U) { io.ctrl.ctrlALUOp := OP_XOR }
//         is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }
//         is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }
//         is("b101".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) }
//       }
//     }

//     // ------------------------------------------------------------
//     // I-type ALU (addi, slti, slli, srli, srai)
//     // ------------------------------------------------------------
//     is(OP_I_ALU) {
//       io.ctrl.ctrlRegWrite := true.B
//       io.ctrl.ctrlALUSrc   := true.B
//       io.imm := sext(inst(31,20), 12)

//       switch(funct3) {
//         is("b000".U) { io.ctrl.ctrlALUOp := OP_ADD }  // addi
//         is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }  // slti
//         is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }  // slli
//         is("b101".U) { 
//           io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) // srai/srli
//         }
//       }
//     }

//     // ------------------------------------------------------------
//     // LOAD (lw)
//     // ------------------------------------------------------------
//     is(OP_LOAD) {
//       io.ctrl.ctrlRegWrite := true.B
//       io.ctrl.ctrlALUSrc   := true.B
//       io.ctrl.ctrlMemRead  := true.B
//       io.ctrl.ctrlMemToReg := true.B
//       io.ctrl.ctrlALUOp    := OP_ADD   // addr = rs1 + imm
//       io.imm := sext(inst(31,20), 12)
//     }

//     // ------------------------------------------------------------
//     // STORE (sw)
//     // ------------------------------------------------------------
//     is(OP_STORE) {
//       io.ctrl.ctrlMemWrite := true.B
//       io.ctrl.ctrlALUSrc   := true.B
//       io.ctrl.ctrlALUOp    := OP_ADD
//       val immS = Cat(inst(31,25), inst(11,7))
//       io.imm := sext(immS, 12)
//     }

//     // ------------------------------------------------------------
//     // BRANCH (beq, bne, blt, bge)
//     // ------------------------------------------------------------
//     is(OP_BRANCH) {
//       io.ctrl.ctrlBranch := true.B
//       val immB = Cat(inst(31), inst(7), inst(30,25), inst(11,8), 0.U(1.W))
//       io.imm := sext(immB, 13)

//       switch(funct3) {
//         is("b000".U) { io.ctrl.ctrlALUOp := OP_BEQ }
//         is("b001".U) { io.ctrl.ctrlALUOp := OP_BNE }
//         is("b100".U) { io.ctrl.ctrlALUOp := OP_BLT }
//         is("b101".U) { io.ctrl.ctrlALUOp := OP_BGE }
//       }
//     }

//     // ------------------------------------------------------------
//     // JAL
//     // ------------------------------------------------------------
//     is(OP_JAL) {
//       io.ctrl.ctrlJump     := true.B
//       io.ctrl.ctrlRegWrite := true.B
//       val immJ = Cat(inst(31), inst(19,12), inst(20), inst(30,21), 0.U(1.W))
//       io.imm := sext(immJ, 21)
//       io.ctrl.ctrlALUOp := OP_JAL
//     }

//     // ------------------------------------------------------------
//     // JALR
//     // ------------------------------------------------------------
//     is(OP_JALR) {
//       io.ctrl.ctrlJump     := true.B
//       io.ctrl.ctrlRegWrite := true.B
//       io.ctrl.ctrlALUSrc   := true.B
//       io.ctrl.ctrlALUOp    := OP_JALR
//       io.imm := sext(inst(31,20), 12)
//     }

//     // ------------------------------------------------------------
//     // LUI
//     // ------------------------------------------------------------
//     is(OP_LUI) {
//       io.ctrl.ctrlRegWrite := true.B
//       io.ctrl.ctrlALUOp    := OP_LUI
//       io.imm := Cat(inst(31,12), Fill(12, 0.U))
//     }

//     // ------------------------------------------------------------
//     // AUIPC
//     // ------------------------------------------------------------
//     is(OP_AUIPC) {
//       io.ctrl.ctrlRegWrite := true.B
//       io.ctrl.ctrlALUOp    := OP_AUIPC
//       io.imm := Cat(inst(31,12), Fill(12, 0.U))
//     }
//   }
// }


package cpu

import chisel3._
import chisel3.util._
import OP_TYPES._

class Decoder_io extends Bundle {
  val inst = Input(UInt(32.W))
  val ctrl = Output(new CtrlSignal)
  val regs = Output(new RegAddr)
  val imm  = Output(UInt(32.W))
}

class Decoder extends Module {
  val io = IO(new Decoder_io())

  val inst   = io.inst
  val opcode = inst(6,0)
  val rd     = inst(11,7)
  val funct3 = inst(14,12)
  val rs1    = inst(19,15)
  val rs2    = inst(24,20)
  val funct7 = inst(31,25)

  // Default outputs
  io.ctrl := 0.U.asTypeOf(new CtrlSignal)
  io.regs.rs1_addr := rs1
  io.regs.rs2_addr := rs2
  io.regs.rd_addr  := rd
  io.imm := 0.U

  // Opcodes  (RENAMED to avoid clashing with OP_TYPES)
  val OPC_R     = "b0110011".U
  val OPC_I_ALU = "b0010011".U
  val OPC_LOAD  = "b0000011".U
  val OPC_STORE = "b0100011".U
  val OPC_BRANCH= "b1100011".U
  val OPC_JAL   = "b1101111".U
  val OPC_JALR  = "b1100111".U
  val OPC_LUI   = "b0110111".U
  val OPC_AUIPC = "b0010111".U

  // Sign-extend helper
  def sext(x: UInt, bits: Int): UInt = {
    Cat(Fill(32 - bits, x(bits-1)), x(bits-1,0))
  }

  switch(opcode) {
    // ------------------------------------------------------------
    // R-type (add, sub, and, or, xor, slt, sll, srl, sra)
    // ------------------------------------------------------------
    is(OPC_R) {
      io.ctrl.ctrlRegWrite := true.B

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SUB, OP_ADD) } // add/sub
        is("b111".U) { io.ctrl.ctrlALUOp := OP_AND }
        is("b110".U) { io.ctrl.ctrlALUOp := OP_OR  }
        is("b100".U) { io.ctrl.ctrlALUOp := OP_XOR }
        is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }
        is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }
        is("b101".U) { io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) }
      }
    }

    // ------------------------------------------------------------
    // I-type ALU (addi, slti, slli, srli, srai)
    // ------------------------------------------------------------
    is(OPC_I_ALU) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.imm := sext(inst(31,20), 12)

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := OP_ADD }  // addi
        is("b010".U) { io.ctrl.ctrlALUOp := OP_SLT }  // slti
        is("b001".U) { io.ctrl.ctrlALUOp := OP_SLL }  // slli
        is("b101".U) {
          io.ctrl.ctrlALUOp := Mux(funct7 === "b0100000".U, OP_SRA, OP_SRL) // srai/srli
        }
      }
    }

    // ------------------------------------------------------------
    // LOAD (lw)
    // ------------------------------------------------------------
    is(OPC_LOAD) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlMemRead  := true.B
      io.ctrl.ctrlMemToReg := true.B
      io.ctrl.ctrlALUOp    := OP_ADD   // addr = rs1 + imm
      io.imm := sext(inst(31,20), 12)
    }

    // ------------------------------------------------------------
    // STORE (sw)
    // ------------------------------------------------------------
    is(OPC_STORE) {
      io.ctrl.ctrlMemWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlALUOp    := OP_ADD
      val immS = Cat(inst(31,25), inst(11,7))
      io.imm := sext(immS, 12)
    }

    // ------------------------------------------------------------
    // BRANCH (beq, bne, blt, bge)
    // ------------------------------------------------------------
    is(OPC_BRANCH) {
      io.ctrl.ctrlBranch := true.B
      val immB = Cat(inst(31), inst(7), inst(30,25), inst(11,8), 0.U(1.W))
      io.imm := sext(immB, 13)

      switch(funct3) {
        is("b000".U) { io.ctrl.ctrlALUOp := OP_BEQ }
        is("b001".U) { io.ctrl.ctrlALUOp := OP_BNE }
        is("b100".U) { io.ctrl.ctrlALUOp := OP_BLT }
        is("b101".U) { io.ctrl.ctrlALUOp := OP_BGE }
      }
    }

    // ------------------------------------------------------------
    // JAL
    // ------------------------------------------------------------
    is(OPC_JAL) {
      io.ctrl.ctrlJump     := true.B
      io.ctrl.ctrlRegWrite := true.B
      val immJ = Cat(inst(31), inst(19,12), inst(20), inst(30,21), 0.U(1.W))
      io.imm := sext(immJ, 21)
      io.ctrl.ctrlALUOp := OP_JAL
    }

    // ------------------------------------------------------------
    // JALR
    // ------------------------------------------------------------
    is(OPC_JALR) {
      io.ctrl.ctrlJump     := true.B
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUSrc   := true.B
      io.ctrl.ctrlALUOp    := OP_JALR
      io.imm := sext(inst(31,20), 12)
    }

    // ------------------------------------------------------------
    // LUI
    // ------------------------------------------------------------
    is(OPC_LUI) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUOp    := OP_LUI      // from OP_TYPES (ALU op), not opcode
      io.imm := Cat(inst(31,12), Fill(12, 0.U))
    }

    // ------------------------------------------------------------
    // AUIPC
    // ------------------------------------------------------------
    is(OPC_AUIPC) {
      io.ctrl.ctrlRegWrite := true.B
      io.ctrl.ctrlALUOp    := OP_AUIPC   // from OP_TYPES
      io.imm := Cat(inst(31,12), Fill(12, 0.U))
    }
  }
}



========================================
File: ForwardUnit.scala
========================================

  package cpu
  import chisel3._
  
  
  /** Forwarding unit for 5-stage pipeline (EX/MEM & MEM/WB -> EX stage).
    * ForwardA / ForwardB encoding:
    *   00 -> use ID/EX register value
    *   10 -> forward from EX/MEM
    *   01 -> forward from MEM/WB
    *   ForwardA for rs1, ForwardB for rs2
    */

  class ForwardUnit extends Module{
    val io = IO(new Bundle{
      val ex_mem_regwrite = Input(Bool())
      val ex_mem_rd       = Input(UInt(5.W))
      val mem_wb_regwrite = Input(Bool())
      val mem_wb_rd       = Input(UInt(5.W))
      val id_ex_rs1       = Input(UInt(5.W))
      val id_ex_rs2       = Input(UInt(5.W))
      val forwardA        = Output(UInt(2.W))
      val forwardB        = Output(UInt(2.W))
    })

    // Default: no forwarding
    io.forwardA := 0.U
    io.forwardB := 0.U

    // EX hazard
    when(io.ex_mem_regwrite && (io.ex_mem_rd =/= 0.U) && (io.ex_mem_rd === io.id_ex_rs1)){
      io.forwardA := "b10".U
    }
    when(io.ex_mem_regwrite && (io.ex_mem_rd =/= 0.U) && (io.ex_mem_rd === io.id_ex_rs2)){
      io.forwardB := "b10".U
    }

    // MEM hazard
    when(io.mem_wb_regwrite && (io.mem_wb_rd =/= 0.U) && 
         !(io.ex_mem_regwrite && (io.ex_mem_rd =/= 0.U) && (io.ex_mem_rd === io.id_ex_rs1)) &&
         (io.mem_wb_rd === io.id_ex_rs1)){
      io.forwardA := "b01".U
    }
    when(io.mem_wb_regwrite && (io.mem_wb_rd =/= 0.U) && 
         !(io.ex_mem_regwrite && (io.ex_mem_rd =/= 0.U) && (io.ex_mem_rd === io.id_ex_rs2)) &&
         (io.mem_wb_rd === io.id_ex_rs2)){
      io.forwardB := "b01".U
    }
  }



========================================
File: InstMem.scala
========================================
package cpu

import chisel3._
import chisel3.util._
import chisel3.util.experimental.loadMemoryFromFile
import firrtl.annotations.MemoryLoadFileType

/// DO NOT MODIFY THIS FILE /// 

class InstMem_io extends Bundle {
    val addr = Input(UInt(32.W)) 
    val inst = Output(UInt(32.W))
}

class InstMem() extends Module {
    val io = IO(new InstMem_io()) 

    // addr divided by 4, byte -> word address
    val index = io.addr >> 2.U 

    val pipeline = sys.env.getOrElse("PIPELINE","0") == "1"

    // declare a memory that can store 1024 32-bit instructions
    val mem: MemBase[UInt] = if(pipeline) {
        SyncReadMem(1024, UInt(32.W))
    } else {
        Mem(1024, UInt(32.W))
    }

    val inst_file = sys.env.getOrElse("INST_FILE", "src/test/pattern/p1.hex")
    loadMemoryFromFile(mem, inst_file, MemoryLoadFileType.Hex)
    println(s"Loading instruction memory from: " + inst_file)
    
    io.inst := mem.read(index)
}



========================================
File: PCHandle.scala
========================================
// package cpu

// import chisel3._
// import chisel3.util._

// class PCHandle_io extends Bundle {
//     /// TODO ///   
//     val to_branch = Input(Bool())
//     val jump_addr = Input(UInt(32.W))

//     // current pc
//     val pc = Output(UInt(32.W))
// }

// class PCHandle extends Module {
//     val io = IO(new PCHandle_io())  

//     val pc = RegInit(UInt(32.W), 0.U) 
    
//     /// TODO ///
//     val next_pc = Mux(io.to_branch, io.jump_addr, pc + 4.U)

//     pc := next_pc
//     io.pc := pc
// }

package cpu

import chisel3._
import chisel3.util._

class PCHandle_io extends Bundle {
  val to_branch = Input(Bool())
  val jump_addr = Input(UInt(32.W))
  val pc        = Output(UInt(32.W))
}

class PCHandle extends Module {
  val io = IO(new PCHandle_io())

  val pc = RegInit(0.U(32.W))

  // basic next PC logic: PC+4 or branch/jump target
  val next_pc = Mux(io.to_branch, io.jump_addr, pc + 4.U)

  pc := next_pc
  io.pc := pc
}



========================================
File: Reg_IF_ID.scala
========================================
package cpu

import chisel3._
import chisel3.util._

/** IF/ID pipeline bundle: values passed from IF to ID */
class IF_ID_Bundle extends Bundle {
  val pc   = UInt(32.W)
  val inst = UInt(32.W)
}

/** IF/ID pipeline register */
class Reg_IF_ID extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new IF_ID_Bundle)
    val out   = Output(new IF_ID_Bundle)
  })

  val reg = RegInit(0.U.asTypeOf(new IF_ID_Bundle))

  when (io.flush) {
    reg := 0.U.asTypeOf(new IF_ID_Bundle)
  } .elsewhen (!io.stall) {
    reg := io.in
  }

  io.out := reg
}

/** ID/EX pipeline bundle: values passed from ID to EX */
class ID_EX_Bundle extends Bundle {
  val pc        = UInt(32.W)
  val rs1_data  = UInt(32.W)
  val rs2_data  = UInt(32.W)
  val imm       = UInt(32.W)
  val regs      = new RegAddr
  val ctrl      = new CtrlSignal
}

/** ID/EX pipeline register */
class Reg_ID_EX extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new ID_EX_Bundle)
    val out   = Output(new ID_EX_Bundle)
  })

  val reg = RegInit(0.U.asTypeOf(new ID_EX_Bundle))

  when (io.flush) {
    reg := 0.U.asTypeOf(new ID_EX_Bundle)
  } .elsewhen (!io.stall) {
    reg := io.in
  }

  io.out := reg
}

/** EX/MEM pipeline bundle: values passed from EX to MEM */
class EX_MEM_Bundle extends Bundle {
  val pc        = UInt(32.W)
  val alu_res   = UInt(32.W)
  val rs2_data  = UInt(32.W)
  val regs      = new RegAddr
  val ctrl      = new CtrlSignal
}

/** EX/MEM pipeline register */
class Reg_EX_MEM extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new EX_MEM_Bundle)
    val out   = Output(new EX_MEM_Bundle)
  })

  val reg = RegInit(0.U.asTypeOf(new EX_MEM_Bundle))

  when (io.flush) {
    reg := 0.U.asTypeOf(new EX_MEM_Bundle)
  } .elsewhen (!io.stall) {
    reg := io.in
  }

  io.out := reg
}

/** MEM/WB pipeline bundle: values passed from MEM to WB */
class MEM_WB_Bundle extends Bundle {
  val pc        = UInt(32.W)
  val mem_data  = UInt(32.W)
  val alu_res   = UInt(32.W)
  val regs      = new RegAddr
  val ctrl      = new CtrlSignal
}

/** MEM/WB pipeline register */
class Reg_MEM_WB extends Module {
  val io = IO(new Bundle {
    val stall = Input(Bool())
    val flush = Input(Bool())
    val in    = Input(new MEM_WB_Bundle)
    val out   = Output(new MEM_WB_Bundle)
  })

  val reg = RegInit(0.U.asTypeOf(new MEM_WB_Bundle))

  when (io.flush) {
    reg := 0.U.asTypeOf(new MEM_WB_Bundle)
  } .elsewhen (!io.stall) {
    reg := io.in
  }

  io.out := reg
}



========================================
File: Regfile.scala
========================================
// package cpu

// import chisel3._
// import chisel3.util._

// class Regfile_io extends Bundle {
//     /// TODO ///
//     val ctrlRegWrite = Input(Bool())
//     val reg_addr = Flipped(new RegAddr()) // input
//     val data_write = Input(UInt(32.W))
//     val data_read1 = Output(UInt(32.W))
//     val data_read2 = Output(UInt(32.W))
    
// }

// class Regfile extends Module {
//     val io = IO(new Regfile_io())

//     // declare 32 registers each 32 bits
//     val regs = Reg(Vec(32, UInt(32.W)))

//     /// TODO ///
//     // read
//     when(io.reg_addr.rs1_addr === 0.U)
//     {
//         io.data_read1 := 0.U
//     }
//     when(io.reg_addr.rs2_addr === 0.U)
//     {
//         io.data_read2 := 0.U
//     }

//     io.data_read1 := regs(io.reg_addr.rs1_addr)
//     io.data_read2 := regs(io.reg_addr.rs2_addr)

//     // write  
//     when(io.ctrlRegWrite && io.reg_addr.rd_addr =/= 0.U)
//     {
//         regs(io.reg_addr.rd_addr) := io.data_write
//     }

// }


package cpu

import chisel3._
import chisel3.util._

class Regfile_io extends Bundle {
  // read ports
  val rs1_addr = Input(UInt(5.W))
  val rs2_addr = Input(UInt(5.W))
  val rs1_data = Output(UInt(32.W))
  val rs2_data = Output(UInt(32.W))
  // write port
  val rd_addr  = Input(UInt(5.W))
  val wdata    = Input(UInt(32.W))
  val wen      = Input(Bool())
}

class Regfile extends Module {
  val io = IO(new Regfile_io())

  // 32 x 32-bit registers, init to 0
  val regs = RegInit(VecInit(Seq.fill(32)(0.U(32.W))))

  // write-back (ignore writes to x0)
  when(io.wen && (io.rd_addr =/= 0.U)) {
    regs(io.rd_addr) := io.wdata
  }

  // read ports (x0 always 0)
  io.rs1_data := Mux(io.rs1_addr === 0.U, 0.U, regs(io.rs1_addr))
  io.rs2_data := Mux(io.rs2_addr === 0.U, 0.U, regs(io.rs2_addr))
}



